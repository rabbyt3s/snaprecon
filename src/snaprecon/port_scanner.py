"""Fast, optional TCP connect-only port scanner for SnapRecon.

Results are intended for HTML reporting only and are not persisted in results.json.
"""

from __future__ import annotations

import asyncio
import contextlib
import html
import logging
from pathlib import Path
from typing import Dict, Iterable, List, Set, Tuple

from .config import AppConfig

logger = logging.getLogger(__name__)


def parse_port_tokens(tokens: Iterable[str]) -> List[int]:
    """Parse tokens like ['80','443','8080-8090'] → sorted unique port ints."""
    ports: Set[int] = set()
    for tok in tokens:
        t = (tok or "").strip()
        if not t:
            continue
        if "-" in t:
            a, b = t.split("-", 1)
            try:
                start, end = int(a), int(b)
                if start > end:
                    start, end = end, start
                for p in range(max(1, start), min(65535, end) + 1):
                    ports.add(p)
            except ValueError:
                logger.debug(f"Ignoring invalid range token: {tok}")
        else:
            try:
                p = int(t)
                if 1 <= p <= 65535:
                    ports.add(p)
            except ValueError:
                logger.debug(f"Ignoring invalid port token: {tok}")
    return sorted(ports)


async def _probe_port(host: str, port: int, timeout: float) -> bool:
    """Return True if TCP connect succeeds within timeout."""
    try:
        fut = asyncio.open_connection(host=host, port=port)
        reader, writer = await asyncio.wait_for(fut, timeout=timeout)
        writer.close()
        with contextlib.suppress(Exception):
            await writer.wait_closed()
        return True
    except Exception:
        return False


async def _scan_host(host: str, ports: List[int], per_connect_timeout: float, sem: asyncio.Semaphore) -> Tuple[str, List[int]]:
    open_ports: List[int] = []

    async def _task(p: int) -> None:
        async with sem:
            if await _probe_port(host, p, per_connect_timeout):
                open_ports.append(p)

    await asyncio.gather(*[_task(p) for p in ports], return_exceptions=True)
    open_ports.sort()
    return host, open_ports


async def scan_ports_for_hosts(hosts: List[str], port_tokens: List[str], max_concurrency: int = 200) -> Dict[str, List[int]]:
    """Scan hosts concurrently using TCP connect-only.

    - max_concurrency controls total concurrent probes (host×port).
    - per_connect_timeout kept short for speed.
    """
    ports = parse_port_tokens(port_tokens) or [80, 443, 8080, 8443, 8000, 3000, 4200]
    sem = asyncio.Semaphore(max(1, max_concurrency))
    per_connect_timeout = 0.4  # seconds; tweak if needed

    logger.info(f"Port scan: {len(hosts)} hosts × {len(ports)} ports, concurrency={max_concurrency}")
    results: Dict[str, List[int]] = {}
    tasks = [_scan_host(h, ports, per_connect_timeout, sem) for h in hosts]
    scanned = await asyncio.gather(*tasks, return_exceptions=True)

    for i, res in enumerate(scanned):
        if isinstance(res, Exception):
            logger.debug(f"Scan error for {hosts[i]}: {res}")
            results[hosts[i]] = []
        else:
            host, open_ports = res
            results[host] = open_ports

    return results


def write_ports_html_report(host_to_ports: Dict[str, List[int]], config: AppConfig) -> Path:
    """Write a standalone ports HTML report (kept for compatibility)."""
    out = config.run_dir / "ports.html"
    rows = []
    for host in sorted(host_to_ports.keys()):
        ports = ", ".join(str(p) for p in host_to_ports[host]) or "—"
        rows.append(f"<tr><td>{html.escape(host)}</td><td>{html.escape(ports)}</td></tr>")
    table = "\n".join(rows)

    html_doc = f"""<!doctype html>
<html lang="en">
<meta charset="utf-8">
<title>SnapRecon Ports</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; padding: 16px; }}
table {{ border-collapse: collapse; width: 100%; }}
th, td {{ border: 1px solid #ddd; padding: 8px; font-size: 14px; }}
th {{ background: #f7f7f7; text-align: left; }}
tr:nth-child(even) {{ background: #fafafa; }}
code {{ background: #f0f0f0; padding: 1px 4px; border-radius: 3px; }}
</style>
<h1>Open Ports (sidecar)</h1>
<p>Generated by SnapRecon. Results are not persisted in results.json.</p>
<p><strong>Run dir:</strong> <code>{html.escape(str(config.run_dir))}</code></p>
<table>
<thead><tr><th>Host</th><th>Open ports</th></tr></thead>
<tbody>
{table}
</tbody>
</table>
</html>
"""
    out.write_text(html_doc, encoding="utf-8")
    return out


